package de.thm.mni.compilerbau.phases._02_03_parser;

import java.util.List;
import java.util.LinkedList;
import java_cup.runtime.*;
import de.thm.mni.compilerbau.phases._01_scanner.Scanner;
import de.thm.mni.compilerbau.absyn.*;
import de.thm.mni.compilerbau.table.Identifier;
import de.thm.mni.compilerbau.utils.SplError;
import de.thm.mni.compilerbau.CommandLineOptions;

parser code {:
  public CommandLineOptions options = null;

  public void syntax_error(Symbol currentToken) {
    // Apparently there is a cup bug that causes expected_token_ids() to return incorrect results on first call
    // This is why this call is inserted.
    this.expected_token_ids();
    
    throw SplError.SyntaxError(new Position(currentToken.left, currentToken.right),
            this.symbl_name_from_id(currentToken.sym),
            this.expected_token_ids().stream().map(this::symbl_name_from_id).toList());
  }
  
  /**
   * @return An empty list. (Uses LinkedList)
   */
  public static <E> List<E> nil() {
      return new LinkedList<E>();
  }
  
  /**
   * Constructs a list from a head and a tail without modifying the tail (Uses LinkedList).
   * Use this as a helper if you don't want to deal with constructing lists manually.
   *
   * @param head The head of the list
   * @param tail The tail of the list
   * @return A list containing the head element and all elements of tail
   */
  public static <E> List<E> cons(E head, List<E> tail) {
    List<E> copy = new LinkedList(tail);
    copy.add(0, head);
    return copy;
  }
:}

/* Terminals/Tokens */
terminal LBRACK, RBRACK, LPAREN, RPAREN, LCURL, RCURL;         //Braces, parenthesis, brackets
terminal LT, LE, GT, GE, NE, EQ;                               //Comparison operators
terminal PLUS, MINUS, STAR, SLASH;                             //Arithmetic operators
terminal ASGN, COMMA, COLON, SEMIC;                            //Other delimiters
terminal TYPE, PROC, ARRAY, OF, REF, VAR, IF, ELSE, WHILE;     //Keywords

terminal Identifier IDENT;    //Identifiers
terminal Integer INTLIT;      //Integer literals

/* Non-terminals */
non terminal Program program;
non terminal GlobalDefinition globalDef;
non terminal List<GlobalDefinition> globalDefList;
non terminal List<ParameterDefinition> parameterDefList;
non terminal ProcedureDefinition procedureDef;
non terminal ProcedureDefinition optionaleParaDef;
non terminal ParameterDefinition parameterDef;
non terminal VariableDefinition variableDef;
non terminal Statement statement;
non terminal IfStatement ifStat;
non terminal IfStatement optionaleEles;
non terminal NamedTypeExpression namedTypeExpr;
non terminal NamedVariable namedVar;
non terminal ArrayAccess arrayAccess;
non terminal optionaleDimension;
non terminal dimensionRest;

non terminal ArrayTypeExpression typeExpr;
non terminal AssignStatement assignStat;

//non terminal BinaryExpression binaryExprPlus;
non terminal BinaryExpression binaryExpr;
non terminal BinaryExpression termPlusMinus;
non terminal BinaryExpression mulDiv;
non terminal BinaryExpression paren;
non terminal BinaryExpression expr;


non terminal CallStatement callStat;
non terminal CompoundStatement compoundStat;
non terminal EmptyStatement emptyStat;
non terminal IntLiteral intLiteral;
non terminal Position position;
non terminal TypeDefinition typeDef;
non terminal UnaryExpression unaryExpr;
non terminal VariableExpression variable;
non terminal WhileStatement whileStat;
non terminal epsilon;
non terminal List<VariableDefinition> variableDefList;
non terminal List<Statement> statementList;
non terminal List<Expression> exprList;
start with program;
//type myInt = int;

program ::=  globalDefList; //TODO (assignment 2 and 3): Just a dummy, needs to be replaced by the actual spl grammar.

globalDef ::= typeDef | procedureDef;

typeDef ::= TYPE IDENT EQ typeExpr SEMIC;

typeExpr ::= ARRAY LBRACK INTLIT RBRACK OF typeExpr  | IDENT;
epsilon ::= ;
//namedTypeExpr ::= IDENT;
//
namedVar ::= IDENT;
statementList ::= epsilon | statement statementList;
variableDef ::= VAR IDENT COLON typeExpr SEMIC;
globalDefList ::= epsilon | globalDef globalDefList;
variableDefList ::= epsilon | variableDef variableDefList;
parameterDef ::= IDENT COLON typeExpr |
                 REF IDENT COLON typeExpr;
parameterDefList ::= parameterDef COMMA parameterDefList | parameterDef ; // TODO FALL (a) now (a,) is allowed
procedureDef ::= PROC IDENT LPAREN optionaleParaDef RPAREN LCURL variableDefList statementList RCURL; //´ TODO epsilon

statement ::= ifStat |
              callStat |
              whileStat |
              emptyStat |
              assignStat |
              compoundStat;
optionaleEles ::= epsilon | ELSE statement;

ifStat ::= IF LPAREN expr RPAREN statement optionaleEles;

compoundStat ::= LCURL statementList RCURL;

whileStat ::= WHILE LPAREN expr RPAREN statement;

emptyStat ::= SEMIC;

callStat ::= IDENT LPAREN exprList RPAREN SEMIC; //TODO ist das richtg bzw expr ändern ??

optionaleParaDef ::= parameterDefList | epsilon;
assignStat ::= variable ASGN termPlusMinus SEMIC;

exprList ::= epsilon | expr COMMA exprList | expr;

arrayAccess ::= IDENT optionaleDimension  ;
optionaleDimension ::= LBRACK expr RBRACK optionaleDimension | epsilon;
expr ::=binaryExpr;//TODO muss zu booleasch baeachtaet werden ???


variable ::=  arrayAccess;

//namedTypeExpr ::= IDENT ;


binaryExpr ::= binaryExpr LE termPlusMinus
             | binaryExpr GT termPlusMinus
             | binaryExpr EQ termPlusMinus
             | binaryExpr LT termPlusMinus
             | binaryExpr NE termPlusMinus
             | binaryExpr GE termPlusMinus
             | termPlusMinus;

termPlusMinus ::= termPlusMinus PLUS mulDiv
                | termPlusMinus MINUS mulDiv
                | mulDiv;

mulDiv ::= mulDiv STAR unaryExpr
         | mulDiv SLASH unaryExpr
         | unaryExpr;

unaryExpr ::= MINUS unaryExpr
            | paren;

paren ::= INTLIT
        | LPAREN expr RPAREN
        | variable;