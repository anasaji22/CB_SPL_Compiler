package de.thm.mni.compilerbau.phases._02_03_parser;

import java.util.List;
import java.util.LinkedList;
import java_cup.runtime.*;
import de.thm.mni.compilerbau.phases._01_scanner.Scanner;
import de.thm.mni.compilerbau.absyn.*;
import de.thm.mni.compilerbau.table.Identifier;
import de.thm.mni.compilerbau.utils.SplError;
import de.thm.mni.compilerbau.CommandLineOptions;

parser code {:
  public CommandLineOptions options = null;

  public void syntax_error(Symbol currentToken) {
    // Apparently there is a cup bug that causes expected_token_ids() to return incorrect results on first call
    // This is why this call is inserted.
    this.expected_token_ids();
    
    throw SplError.SyntaxError(new Position(currentToken.left, currentToken.right),
            this.symbl_name_from_id(currentToken.sym),
            this.expected_token_ids().stream().map(this::symbl_name_from_id).toList());
  }
  
  /**
   * @return An empty list. (Uses LinkedList)
   */
  public static <E> List<E> nil() {
      return new LinkedList<E>();
  }
  
  /**
   * Constructs a list from a head and a tail without modifying the tail (Uses LinkedList).
   * Use this as a helper if you don't want to deal with constructing lists manually.
   *
   * @param head The head of the list
   * @param tail The tail of the list
   * @return A list containing the head element and all elements of tail
   */
  public static <E> List<E> cons(E head, List<E> tail) {
    List<E> copy = new LinkedList(tail);
    copy.add(0, head);
    return copy;
  }
:}

/* Terminals/Tokens */
terminal LBRACK, RBRACK, LPAREN, RPAREN, LCURL, RCURL;         //Braces, parenthesis, brackets
terminal LT, LE, GT, GE, NE, EQ;                               //Comparison operators
terminal PLUS, MINUS, STAR, SLASH;                             //Arithmetic operators
terminal ASGN, COMMA, COLON, SEMIC;                            //Other delimiters
terminal TYPE, PROC, ARRAY, OF, REF, VAR, IF, ELSE, WHILE;     //Keywords

terminal Identifier IDENT;    //Identifiers
terminal Integer INTLIT;      //Integer literals

/* Non-terminals */
non terminal Program program;
non terminal GlobalDefinition globalDef;
non terminal List<GlobalDefinition> globalDefList;
non terminal List<ParameterDefinition> parameterDefList;
non terminal ProcedureDefinition procedureDef;
non terminal ParameterDefinition parameterDef;
non terminal VariableDefinition variableDef;
non terminal Statement statement;
non terminal IfStatement ifStat;
non terminal IfStatement ifStatWithElse;
non terminal NamedTypeExpression namedTypeExpr;
non terminal NamedVariable namedVar;
non terminal ArrayAccess arrayAccess;
non terminal ArrayTypeExpression typeExpr;
non terminal AssignStatement assignStat;

//non terminal BinaryExpression binaryExprPlus;
non terminal BinaryExpression binaryExpr;
non terminal BinaryExpression termPlusMinus;
non terminal BinaryExpression mulDiv;
non terminal BinaryExpression paren;
non terminal BinaryExpression expr;


non terminal CallStatement callStat;
non terminal CompoundStatement compoundStat;
non terminal EmptyStatement emptyStat;
non terminal IntLiteral intLiteral;
non terminal Position position;
non terminal TypeDefinition typeDef;
non terminal UnaryExpression unaryExpr;
non terminal VariableExpression variableExpr;
non terminal WhileStatement whileStat;

start with program;
//type myInt = int;

program ::=  globalDef; //TODO (assignment 2 and 3): Just a dummy, needs to be replaced by the actual spl grammar.

globalDef ::= typeDef | procedureDef;

typeDef ::= TYPE IDENT EQ typeExpr SEMIC;

typeExpr ::= ARRAY LBRACK INTLIT RBRACK OF typeExpr  | IDENT;

namedTypeExpr ::= IDENT;

namedVar ::= IDENT;

variableDef ::= VAR IDENT COLON namedTypeExpr SEMIC | typeExpr ;

parameterDef ::= IDENT COLON namedTypeExpr |
                 REF IDENT COLON namedTypeExpr;

statement ::= ifStat |
              callStat |
              whileStat |
              emptyStat |
              assignStat |
              compoundStat;

ifStat ::= IF LPAREN expr RPAREN statement | ifStatWithElse ; // ToDo else

ifStatWithElse ::= IF LPAREN expr RPAREN statement ELSE statement;

compoundStat ::= LCURL statement RCURL;

whileStat ::= LPAREN expr RPAREN statement;

emptyStat ::= SEMIC;

callStat ::= IDENT LPAREN parameterDefList RPAREN SEMIC; //TODO paramater liste and not parameter defenition

parameterDefList ::= parameterDef COMMA parameterDefList | parameterDef; // TODO FALL (a) now (a,) is allowed

procedureDef ::= PROC IDENT LPAREN parameterDefList RPAREN compoundStat; //Â´ TODO Variable deklaration


//TOASK:: darf man die geschweifte Klammer so lassen ??

//proc printErrorUnexpectedEndOfInput(ref success: int) {
//    {
//	printc('['); printc('e'); printc('r'); printc('r'); printc('o'); printc('r'); printc(']'); printc(' ');
//	printc('u'); printc('n'); printc('e'); printc('x'); printc('p'); printc('e'); printc('c'); printc('t');
//	printc('e'); printc('d'); printc(' '); printc('e'); printc('n'); printc('d'); printc(' '); printc('o');
//	printc('f'); printc(' '); printc('i'); printc('n'); printc('p'); printc('u'); printc('t'); printc('\n');
//    }
//	success := 0;
//}
//



arrayAccess ::= IDENT LBRACK INTLIT RBRACK SEMIC; // TODO Mehr demesional beachten
expr ::= INTLIT;//TODO muss zu booleasch baeachtaet werden ???

//namedVar ::= IDENT  or  //arrayAccess // INITLIT;
//variableDef ::= VAR namedVar COLON namedTypeExpr SEMIC;
//variableDef ::= VAR IDENT COLON namedTypeExpr SEMIC;


//binaryExprPlus ::= INTLIT  PLUS binaryExprPlus | INTLIT


//variableExpr ::= namedVar ASGN INTLIT | namedVar ASGN namedVar | namedVar ASGN arrayAccess ;

//
//binaryExpr ::=  binaryexpr1
//             | binaryExpr plus binaryexpr1
//             | binaryExpr minus binaryexpr1
//             binaryexpr1::= binaryexpr2
//             | binaryexpr1 Star binaryexpr 2
//             |  binaryexpr1 slash binaryexpr 2
//
//binaryExpr ::=  binaryExprPlMIN PLUS binaryExprPlMIN ;
//namedTypeExpr ::= IDENT ;
//


//binaryExpr ::= termPlusMinus LE termPlusMinus |
//               termPlusMinus GT termPlusMinus |
//               termPlusMinus EQ termPlusMinus |
//               termPlusMinus LT termPlusMinus |
//               termPlusMinus NE termPlusMinus |
//               termPlusMinus GE termPlusMinus;

//
//binaryExpr ::= termPlusMinus |
//               binaryExpr LE binaryExpr |
//               binaryExpr GT binaryExpr |
//               binaryExpr EQ binaryExpr |
//               binaryExpr LT binaryExpr |
//               binaryExpr NE binaryExpr |
//               binaryExpr GE binaryExpr;
//
binaryExpr ::= termPlusMinus |
               binaryExpr LE termPlusMinus |
               binaryExpr GT termPlusMinus |
               binaryExpr EQ termPlusMinus |
               binaryExpr LT termPlusMinus |
               binaryExpr NE termPlusMinus |
               binaryExpr GE termPlusMinus;

termPlusMinus ::= mulDiv |
                    termPlusMinus PLUS mulDiv |
                    termPlusMinus MINUS mulDiv;

mulDiv ::= paren |
            mulDiv STAR paren
            mulDiv SLASH paren;
paren ::= INTLIT |
            LPAREN binaryExpr RPAREN
            | IDENT;
